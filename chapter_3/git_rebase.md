## 变基

在 Git 中，将一个分支的更改集成到另一个分支中主要有两种方法：merge（合并）和 rebase（变基）

## 基本变基

使用 rebase 命令，您可以获取在一个分支上提交的所有更改，并将其重新应用到另一个分支上。

git checkout experiment

git rebase master

此操作的工作原理是：转到两个分支的共同祖先（您所在的和您要变基到的分支），获取您所在分支的每个提交引入的差异，将这些差异保存到临时文件中，将当前分支重置到与您要变基到的分支相同的提交，最后依次应用每个更改。

https://git-scm.cn/book/en/v2/Git-Branching-Rebasing

变基使历史记录更清晰。如果您检查变基分支的日志，它看起来像一个线性历史记录：即使最初是并行发生的，它看起来所有工作都是按顺序发生的。

通常，您会这样做以确保您的提交在远程分支上干净地应用——也许是在您尝试为其贡献代码但您不维护的项目中。在这种情况下，您将在一个分支中完成您的工作，然后在准备好将您的补丁提交到主项目时，将您的工作变基到 origin/master。这样，维护人员就不需要执行任何集成工作——只需快速向前或干净应用即可。

请注意，最终生成的最终提交指向的快照，无论是变基的最后一个提交还是合并后的最终合并提交，都是相同的快照——只有历史记录不同。变基会按引入的顺序将一条工作线上的更改重新应用到另一条工作线上，而合并则将端点合并在一起。

## 更有趣的变基

git rebase --onto master server client

这基本上表示：“获取client分支，找出它与server分支分叉以来的补丁，并将这些补丁重新应用到client分支上，就好像它直接基于master分支一样。

假设你决定也引入你的server分支。你可以通过运行git rebase <basebranch> <topicbranch>将server分支变基到master分支上，而无需先检出它——这会为你检出主题分支（在本例中为server），并将其重新应用到基础分支（master）上。

git rebase master server


## 变基的风险

不要变基存在于你的仓库之外且其他人可能已经基于其进行工作提交。

当你变基时，你放弃了现有的提交，并创建了新的、相似但不同的提交。如果你将提交推送到某个地方，其他人拉取它们并基于它们进行工作，然后你使用git rebase重写这些提交并再次推送，你的协作者将不得不重新合并他们的工作，当你尝试将他们的工作拉回你的工作时，事情会变得混乱。

## 变基时应注意什么

如果你确实发现自己处于这种情况，Git 有一些额外的魔法可能可以帮助你。如果你的团队中的某个人强制推送覆盖了你已基于其工作的更改，你的挑战是弄清楚哪些是你的，哪些是被他们重写的。

git rebase teamone/master 变基到远程分支，而不是pull进行合并

你也可以通过运行git pull --rebase而不是普通的git pull来简化此操作。或者你可以在这种情况下手动执行git fetch，然后执行git rebase teamone/master。

如果你正在使用git pull并希望将--rebase设置为默认值，你可以使用类似于git config --global pull.rebase true的内容设置pull.rebase配置值。

## 变基与合并

既然你已经看到了变基和合并的实际操作，你可能想知道哪一个更好。在我们能够回答这个问题之前，让我们退一步，谈谈历史的意义。

关于这一点的一个观点是，你的仓库的提交历史是实际发生的事情的记录。它是一份历史文献，本身就很有价值，不应该被篡改。从这个角度来看，更改提交历史几乎是亵渎神灵；你是在撒谎关于实际发生的事情。那么，如果有一系列混乱的合并提交又如何呢？这就是它发生的方式，仓库应该将其保存以供后代参考。

相反的观点是，提交历史是你的项目是如何创建的故事。你不会出版一本书的第一稿，那么为什么要展示你杂乱无章的工作呢？当你处理一个项目时，你可能需要记录下你所有失误和死胡同的路径，但是当是时候向世界展示你的工作时，你可能希望讲述一个更连贯的故事，说明如何从 A 到 B。这个阵营中的人们使用rebase和filter-branch等工具在将他们的提交合并到主线分支之前重写它们。他们使用rebase和filter-branch等工具，以最适合未来读者的方式讲述故事。

现在，关于合并还是变基更好的问题：希望你能够看到，事情并没有那么简单。Git 是一款强大的工具，允许你对你的历史进行许多操作，但每个团队和每个项目都不同。现在你已经了解了这两者的工作原理，现在由你来决定哪一个最适合你的特定情况。

你可以获得两全其美：在推送之前变基本地更改以清理你的工作，但永远不要变基你已经推送到某个地方的任何内容。

