## 变基

在 Git 中，将一个分支的更改集成到另一个分支中主要有两种方法：merge（合并）和 rebase（变基）

## 基本变基

使用 rebase 命令，您可以获取在一个分支上提交的所有更改，并将其重新应用到另一个分支上。

git checkout experiment

git rebase master

此操作的工作原理是：转到两个分支的共同祖先（您所在的和您要变基到的分支），获取您所在分支的每个提交引入的差异，将这些差异保存到临时文件中，将当前分支重置到与您要变基到的分支相同的提交，最后依次应用每个更改。

https://git-scm.cn/book/en/v2/Git-Branching-Rebasing

变基使历史记录更清晰。如果您检查变基分支的日志，它看起来像一个线性历史记录：即使最初是并行发生的，它看起来所有工作都是按顺序发生的。

通常，您会这样做以确保您的提交在远程分支上干净地应用——也许是在您尝试为其贡献代码但您不维护的项目中。在这种情况下，您将在一个分支中完成您的工作，然后在准备好将您的补丁提交到主项目时，将您的工作变基到 origin/master。这样，维护人员就不需要执行任何集成工作——只需快速向前或干净应用即可。

请注意，最终生成的最终提交指向的快照，无论是变基的最后一个提交还是合并后的最终合并提交，都是相同的快照——只有历史记录不同。变基会按引入的顺序将一条工作线上的更改重新应用到另一条工作线上，而合并则将端点合并在一起。

## 更有趣的变基

git rebase --onto master server client

这基本上表示：“获取client分支，找出它与server分支分叉以来的补丁，并将这些补丁重新应用到client分支上，就好像它直接基于master分支一样。

假设你决定也引入你的server分支。你可以通过运行git rebase <basebranch> <topicbranch>将server分支变基到master分支上，而无需先检出它——这会为你检出主题分支（在本例中为server），并将其重新应用到基础分支（master）上。

git rebase master server


## 变基的风险

不要变基存在于你的仓库之外且其他人可能已经基于其进行工作提交。

当你变基时，你放弃了现有的提交，并创建了新的、相似但不同的提交。如果你将提交推送到某个地方，其他人拉取它们并基于它们进行工作，然后你使用git rebase重写这些提交并再次推送，你的协作者将不得不重新合并他们的工作，当你尝试将他们的工作拉回你的工作时，事情会变得混乱。

## 变基时应注意什么

如果你确实发现自己处于这种情况，Git 有一些额外的魔法可能可以帮助你。如果你的团队中的某个人强制推送覆盖了你已基于其工作的更改，你的挑战是弄清楚哪些是你的，哪些是被他们重写的。

git rebase teamone/master 变基到远程分支，而不是pull进行合并

你也可以通过运行git pull --rebase而不是普通的git pull来简化此操作。或者你可以在这种情况下手动执行git fetch，然后执行git rebase teamone/master。

如果你正在使用git pull并希望将--rebase设置为默认值，你可以使用类似于git config --global pull.rebase true的内容设置pull.rebase配置值。

## 变基与合并

既然你已经看到了变基和合并的实际操作，你可能想知道哪一个更好。在我们能够回答这个问题之前，让我们退一步，谈谈历史的意义。

关于这一点的一个观点是，你的仓库的提交历史是实际发生的事情的记录。它是一份历史文献，本身就很有价值，不应该被篡改。从这个角度来看，更改提交历史几乎是亵渎神灵；你是在撒谎关于实际发生的事情。那么，如果有一系列混乱的合并提交又如何呢？这就是它发生的方式，仓库应该将其保存以供后代参考。

相反的观点是，提交历史是你的项目是如何创建的故事。你不会出版一本书的第一稿，那么为什么要展示你杂乱无章的工作呢？当你处理一个项目时，你可能需要记录下你所有失误和死胡同的路径，但是当是时候向世界展示你的工作时，你可能希望讲述一个更连贯的故事，说明如何从 A 到 B。这个阵营中的人们使用rebase和filter-branch等工具在将他们的提交合并到主线分支之前重写它们。他们使用rebase和filter-branch等工具，以最适合未来读者的方式讲述故事。

现在，关于合并还是变基更好的问题：希望你能够看到，事情并没有那么简单。Git 是一款强大的工具，允许你对你的历史进行许多操作，但每个团队和每个项目都不同。现在你已经了解了这两者的工作原理，现在由你来决定哪一个最适合你的特定情况。

你可以获得两全其美：在推送之前变基本地更改以清理你的工作，但永远不要变基你已经推送到某个地方的任何内容。


Git 的 `merge` 和 `rebase` 都是用于整合不同分支代码的命令，但它们的实现方式、使用场景和对提交历史的影响有显著区别。以下是两者的详细对比：

---

### **1. 核心区别**
| **特性**         | **`git merge`**                          | **`git rebase`**                        |
|-------------------|------------------------------------------|-----------------------------------------|
| **历史记录**      | 保留分支的原始提交，生成新的合并提交      | 将提交线性化，不保留分支的原始合并点     |
| **提交树结构**    | 形成分叉的树状结构（保留分支独立性）      | 形成线性结构（重写提交历史）             |
| **适用场景**      | 公共分支（如 `main`、`develop`）          | 个人本地分支（尚未共享的分支）           |
| **冲突处理**      | 在最终合并提交时一次性解决所有冲突        | 在每一步提交重放时逐个解决冲突            |
| **历史可追溯性**  | 明确保留分支合并的上下文                  | 隐藏分支合并细节，简化历史               |

---

### **2. 工作流程对比**
#### **(1) 初始状态**
假设有两个分支：
- `main`：基础分支，有提交 `A -> B -> C`
- `feature`：从 `B` 分出的新分支，有提交 `D -> E`

```bash
A - B - C (main)
     \
      D - E (feature)
```

---

#### **(2) 使用 `git merge`**
执行 `git checkout main` + `git merge feature`：
- 生成一个新的**合并提交** `F`，保留分支历史。
- 提交树变为分叉结构：

```bash
A - B - C - F (main)
     \     /
      D - E (feature)
```

---

#### **(3) 使用 `git rebase`**
执行 `git checkout feature` + `git rebase main`：
- 将 `feature` 的提交 `D` 和 `E` **重新应用**到 `main` 的最新提交 `C` 之后。
- 提交树变为线性结构：

```bash
A - B - C - D' - E' (main, feature)
```

---

### **3. 使用场景建议**
#### **何时用 `git merge`？**
- 合并**公共分支**（如多人协作的 `develop` 分支）。
- 需要明确保留分支合并的上下文（例如记录功能开发的完整过程）。
- 避免重写已推送的提交历史（防止破坏他人代码）。

#### **何时用 `git rebase`？**
- 整理**本地分支**的提交历史（如清理冗余的 `WIP` 提交）。
- 保持主分支历史线性整洁（避免无意义的合并提交）。
- 将本地分支与远程主分支同步（例如 `git pull --rebase`）。

---

### **4. 风险与注意事项**
#### **`git merge` 的缺点**
- 提交历史可能变得复杂（尤其是频繁合并时）。
- 合并提交可能掩盖实际开发路径。

#### **`git rebase` 的缺点**
- **重写历史**：如果对已推送的分支执行 `rebase`，会强制覆盖远程历史，可能导致协作混乱。
- **冲突处理复杂**：需要逐提交解决冲突（而 `merge` 是集中解决）。
- **丢失上下文**：隐藏分支的原始分叉点，可能不利于追溯问题。

---

### **5. 最佳实践**
1. **公共分支用 `merge`，私有分支用 `rebase`**
   例如：
   ```bash
   # 同步远程 main 分支到本地 feature 分支
   git checkout feature
   git fetch origin
   git rebase origin/main   # 本地整理提交
   git push origin feature  # 强制推送（仅限私有分支！）

   # 合并 feature 到 main
   git checkout main
   git merge --no-ff feature  # 保留合并提交
   ```

2. **避免对已共享的分支执行 `rebase`**
   如果分支已推送到远程仓库且被他人使用，强制推送重写历史会导致他人代码混乱。

3. **使用 `--force-with-lease` 代替 `--force`**
   在强制推送时更安全：
   ```bash
   git push --force-with-lease origin feature
   ```

4. **交互式变基（Interactive Rebase）**
   使用 `git rebase -i` 整理提交（合并、重排、修改提交信息等）：
   ```bash
   git rebase -i HEAD~3  # 修改最近3个提交
   ```

---

### **6. 总结**
| **决策因素**       | **选择 `merge`**                      | **选择 `rebase`**                  |
|---------------------|---------------------------------------|-------------------------------------|
| **历史清晰度**      | 接受分叉历史                          | 需要线性历史                        |
| **分支是否已共享**  | 是                                    | 否（仅限本地分支）                  |
| **冲突处理偏好**    | 一次性解决所有冲突                    | 逐步解决冲突                        |
| **团队协作规范**    | 要求保留合并上下文                    | 要求提交历史简洁                    |

---

**最终建议**：
- 如果你是新手，优先使用 `git merge`，避免误操作。
- 熟悉 Git 后，在私有分支中合理使用 `rebase` 保持历史整洁。
- 团队协作时，务必遵循统一的流程规范！

