## 修订选择

Git 允许您以多种方式引用单个提交、一组提交或提交范围。它们并非显而易见，但值得了解。

### 单个修订

您可以通过完整的 40 个字符的 SHA-1 哈希值来引用任何单个提交，但也有更人性化的方式来引用提交。本节概述了您可以用来引用任何提交的各种方法。

#### 简短 SHA-1

Git 足够智能，可以识别您要引用的提交，即使您只提供 SHA-1 哈希值的前几个字符，只要该部分哈希值至少有四个字符并且是唯一的；也就是说，对象数据库中没有其他对象可以具有以相同前缀开头的哈希值。

git show a715a8022

git show a715a80229816ef2cb54893c3b5d981bfc7a585f

如果您向 git log 命令传递 --abbrev-commit，则输出将使用较短的值，但会保持它们唯一；默认情况下使用七个字符，但如果需要则会延长它们以保持 SHA-1 的唯一性

git log --abbrev-commit --pretty=oneline


#### 分支引用

git show experiment 

如果你想查看分支指向的特定 SHA-1，或者如果你想查看这些示例中的任何一个最终会转换为 SHA-1，可以使用一个名为 rev-parse 的 Git 底层工具。

git rev-parse topic1


#### RefLog 简写

Git 在后台运行时会做的一件事是保留一个“reflog”——记录你的 HEAD 和分支引用在过去几个月中的位置。

你可以使用 git reflog 查看你的 reflog。

git reflog

每次你的分支顶端因任何原因更新时，Git 都会将该信息存储在该临时历史记录中。你也可以使用你的 reflog 数据来引用旧提交。

如果你想查看存储库的 HEAD 的第五个先前值，可以使用 reflog 输出中看到的 @{5} 引用。
   
git show HEAD@{5}

git show master@{yesterday}

要以类似于 git log 输出的格式查看 reflog 信息，可以运行 git log -g。

重要的是要注意，reflog 信息是严格本地的——它仅是你在你的存储库中所做操作的日志。这些引用在其他人对存储库的副本中将不相同；

此外，在你最初克隆存储库之后，你的 reflog 将为空，因为你的存储库中尚未发生任何活动。运行 git show HEAD@{2.months.ago} 将仅在你至少在两个月前克隆了项目时才会显示匹配的提交——如果你的克隆时间比这更近，则只会显示你的第一个本地提交。

将 reflog 视为 Git 的 shell 历史记录版本

如果你具有 UNIX 或 Linux 背景，你可以将 reflog 视为 Git 的 shell 历史记录版本，这强调了其中的内容对你和你的“会话”来说是相关的，与可能在同一台机器上工作的其他人无关。

## 祖先引用

指定提交的另一种主要方法是通过其祖先。如果你在引用的末尾放置一个 ^（脱字符），Git 会将其解析为该提交的父级。假设你查看项目的历史记录

然后，你可以通过指定 HEAD^ 来查看之前的提交，这意味着“HEAD 的父级”。

git show HEAD^

你也可以在 ^ 之后指定一个数字来标识你想要的哪个父级；例如，d921970^2 表示“d921970 的第二个父级”。这种语法仅对合并提交有用，合并提交具有多个父级——合并提交的第一个父级来自你合并时所在的的分支（通常是 master），而合并提交的第二个父级来自已合并的分支（例如，topic）。

git show d921970^

git show d921970^2

另一个主要的祖先规范是 ~（波浪号）。它也引用第一个父级，因此 HEAD~ 和 HEAD^ 是等效的。区别在于你指定数字时。HEAD~2 表示“第一个父级的第一个父级”，或“祖父母”——它根据你指定的次数遍历第一个父级。

git show HEAD~3

这也可以写成 HEAD~~~，它也是第一个父级的第一个父级的第一个父级。

git show HEAD~~~

## 提交范围

现在你已经可以指定单个提交，让我们来看看如何指定提交范围。这对于管理你的分支特别有用——如果你有很多分支，你可以使用范围规范来回答诸如“此分支上有哪些工作是我尚未合并到主分支中的？”之类的问题。

### 双点

最常见的范围规范是双点语法。这基本上是要求 Git 解析一个从一个提交可访问但从另一个提交不可访问的提交范围。例如，假设你有一个类似于 范围选择示例历史记录的提交历史记录。

假设你想查看你的 experiment 分支中尚未合并到 master 分支中的内容。你可以要求 Git 使用 master..experiment 显示仅这些提交的日志——这意味着“所有从 experiment 可访问但从 master 不可访问的提交”。

git log master..experiment

另一方面，如果你想查看相反的情况——master 中所有不可从 experiment 访问的提交——可以反转分支名称。

git log experiment..master

如果你想保持 experiment 分支的最新状态并预览即将合并的内容，这将非常有用。此语法的另一个常见用途是查看即将推送到远程的内容。

git log origin/master..HEAD

### 多个点

双点语法用作简写很有用，但也许你想要指定两个以上的分支来指示你的修订，例如查看几个分支中的任何一个中所有不在当前分支中的提交。Git 允许你通过在任何你不希望看到可访问提交的引用的前面使用 ^ 字符或 --not 来执行此操作。因此，以下三个命令是等效的

$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA

这很好，因为通过这种语法，你可以在查询中指定两个以上引用，而双点语法无法做到这一点。例如，如果你想查看所有从 refA 或 refB 可访问但从 refC 不可访问的提交，可以使用以下任一方法

$ git log refA refB ^refC
$ git log refA refB --not refC

### 三点

最后一个主要的范围选择语法是三点语法，它指定了可由两个引用中的任何一个到达但不能由两者都到达的所有提交。

git log master...experiment

在这种情况下，与log命令一起使用的常见开关是--left-right，它会显示每个提交位于范围的哪一边。 这有助于使输出更有用

git log --left-right master...experiment


